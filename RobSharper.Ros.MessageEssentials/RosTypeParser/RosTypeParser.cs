//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.7.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from /home/brg/dev/ros-message-parser-cli/RobSharper.Ros.MessageEssentials/RosType.g4 by ANTLR 4.7.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Joanneum.Robotics.Ros.MessageBase.RosTypeParser {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7.2")]
[System.CLSCompliant(false)]
public partial class RosTypeParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		BOOL=1, INT8=2, UINT8=3, BYTE=4, CHAR=5, INT16=6, UINT16=7, INT32=8, UINT32=9, 
		INT64=10, UINT64=11, FLOAT32=12, FLOAT64=13, STRING=14, TIME=15, DURATION=16, 
		SLASH=17, OPEN_BRACKET=18, CLOSE_BRACKET=19, INTEGER_LITERAL=20, IDENTIFIER=21;
	public const int
		RULE_type_input = 0, RULE_type = 1, RULE_built_in_type = 2, RULE_ros_type = 3, 
		RULE_ros_package_type = 4, RULE_array_type = 5, RULE_variable_array_type = 6, 
		RULE_fixed_array_type = 7;
	public static readonly string[] ruleNames = {
		"type_input", "type", "built_in_type", "ros_type", "ros_package_type", 
		"array_type", "variable_array_type", "fixed_array_type"
	};

	private static readonly string[] _LiteralNames = {
		null, "'bool'", "'int8'", "'uint8'", "'byte'", "'char'", "'int16'", "'uint16'", 
		"'int32'", "'uint32'", "'int64'", "'uint64'", "'float32'", "'float64'", 
		"'string'", "'time'", "'duration'", "'/'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "BOOL", "INT8", "UINT8", "BYTE", "CHAR", "INT16", "UINT16", "INT32", 
		"UINT32", "INT64", "UINT64", "FLOAT32", "FLOAT64", "STRING", "TIME", "DURATION", 
		"SLASH", "OPEN_BRACKET", "CLOSE_BRACKET", "INTEGER_LITERAL", "IDENTIFIER"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "RosType.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static RosTypeParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public RosTypeParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public RosTypeParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class Type_inputContext : ParserRuleContext {
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(RosTypeParser.Eof, 0); }
		public Array_typeContext array_type() {
			return GetRuleContext<Array_typeContext>(0);
		}
		public Type_inputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_input; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterType_input(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitType_input(this);
		}
	}

	[RuleVersion(0)]
	public Type_inputContext type_input() {
		Type_inputContext _localctx = new Type_inputContext(Context, State);
		EnterRule(_localctx, 0, RULE_type_input);
		try {
			State = 22;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 16; type();
				State = 17; Match(Eof);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 19; array_type();
				State = 20; Match(Eof);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		public Built_in_typeContext built_in_type() {
			return GetRuleContext<Built_in_typeContext>(0);
		}
		public Ros_typeContext ros_type() {
			return GetRuleContext<Ros_typeContext>(0);
		}
		public Ros_package_typeContext ros_package_type() {
			return GetRuleContext<Ros_package_typeContext>(0);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 2, RULE_type);
		try {
			State = 27;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 24; built_in_type();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 25; ros_type();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 26; ros_package_type();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Built_in_typeContext : ParserRuleContext {
		public ITerminalNode INT8() { return GetToken(RosTypeParser.INT8, 0); }
		public ITerminalNode UINT8() { return GetToken(RosTypeParser.UINT8, 0); }
		public ITerminalNode INT16() { return GetToken(RosTypeParser.INT16, 0); }
		public ITerminalNode UINT16() { return GetToken(RosTypeParser.UINT16, 0); }
		public ITerminalNode INT32() { return GetToken(RosTypeParser.INT32, 0); }
		public ITerminalNode UINT32() { return GetToken(RosTypeParser.UINT32, 0); }
		public ITerminalNode INT64() { return GetToken(RosTypeParser.INT64, 0); }
		public ITerminalNode UINT64() { return GetToken(RosTypeParser.UINT64, 0); }
		public ITerminalNode BYTE() { return GetToken(RosTypeParser.BYTE, 0); }
		public ITerminalNode CHAR() { return GetToken(RosTypeParser.CHAR, 0); }
		public ITerminalNode FLOAT32() { return GetToken(RosTypeParser.FLOAT32, 0); }
		public ITerminalNode FLOAT64() { return GetToken(RosTypeParser.FLOAT64, 0); }
		public ITerminalNode TIME() { return GetToken(RosTypeParser.TIME, 0); }
		public ITerminalNode DURATION() { return GetToken(RosTypeParser.DURATION, 0); }
		public ITerminalNode STRING() { return GetToken(RosTypeParser.STRING, 0); }
		public ITerminalNode BOOL() { return GetToken(RosTypeParser.BOOL, 0); }
		public Built_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_built_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterBuilt_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitBuilt_in_type(this);
		}
	}

	[RuleVersion(0)]
	public Built_in_typeContext built_in_type() {
		Built_in_typeContext _localctx = new Built_in_typeContext(Context, State);
		EnterRule(_localctx, 4, RULE_built_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 29;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BOOL) | (1L << INT8) | (1L << UINT8) | (1L << BYTE) | (1L << CHAR) | (1L << INT16) | (1L << UINT16) | (1L << INT32) | (1L << UINT32) | (1L << INT64) | (1L << UINT64) | (1L << FLOAT32) | (1L << FLOAT64) | (1L << STRING) | (1L << TIME) | (1L << DURATION))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ros_typeContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(RosTypeParser.IDENTIFIER, 0); }
		public Ros_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ros_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterRos_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitRos_type(this);
		}
	}

	[RuleVersion(0)]
	public Ros_typeContext ros_type() {
		Ros_typeContext _localctx = new Ros_typeContext(Context, State);
		EnterRule(_localctx, 6, RULE_ros_type);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 31; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Ros_package_typeContext : ParserRuleContext {
		public ITerminalNode[] IDENTIFIER() { return GetTokens(RosTypeParser.IDENTIFIER); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(RosTypeParser.IDENTIFIER, i);
		}
		public ITerminalNode SLASH() { return GetToken(RosTypeParser.SLASH, 0); }
		public Ros_package_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ros_package_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterRos_package_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitRos_package_type(this);
		}
	}

	[RuleVersion(0)]
	public Ros_package_typeContext ros_package_type() {
		Ros_package_typeContext _localctx = new Ros_package_typeContext(Context, State);
		EnterRule(_localctx, 8, RULE_ros_package_type);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 33; Match(IDENTIFIER);
			State = 34; Match(SLASH);
			State = 35; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_typeContext : ParserRuleContext {
		public Variable_array_typeContext variable_array_type() {
			return GetRuleContext<Variable_array_typeContext>(0);
		}
		public Fixed_array_typeContext fixed_array_type() {
			return GetRuleContext<Fixed_array_typeContext>(0);
		}
		public Array_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterArray_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitArray_type(this);
		}
	}

	[RuleVersion(0)]
	public Array_typeContext array_type() {
		Array_typeContext _localctx = new Array_typeContext(Context, State);
		EnterRule(_localctx, 10, RULE_array_type);
		try {
			State = 39;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 37; variable_array_type();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 38; fixed_array_type();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_array_typeContext : ParserRuleContext {
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode OPEN_BRACKET() { return GetToken(RosTypeParser.OPEN_BRACKET, 0); }
		public ITerminalNode CLOSE_BRACKET() { return GetToken(RosTypeParser.CLOSE_BRACKET, 0); }
		public Variable_array_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_array_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterVariable_array_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitVariable_array_type(this);
		}
	}

	[RuleVersion(0)]
	public Variable_array_typeContext variable_array_type() {
		Variable_array_typeContext _localctx = new Variable_array_typeContext(Context, State);
		EnterRule(_localctx, 12, RULE_variable_array_type);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 41; type();
			State = 42; Match(OPEN_BRACKET);
			State = 43; Match(CLOSE_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Fixed_array_typeContext : ParserRuleContext {
		public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		public ITerminalNode OPEN_BRACKET() { return GetToken(RosTypeParser.OPEN_BRACKET, 0); }
		public ITerminalNode INTEGER_LITERAL() { return GetToken(RosTypeParser.INTEGER_LITERAL, 0); }
		public ITerminalNode CLOSE_BRACKET() { return GetToken(RosTypeParser.CLOSE_BRACKET, 0); }
		public Fixed_array_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fixed_array_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.EnterFixed_array_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRosTypeListener typedListener = listener as IRosTypeListener;
			if (typedListener != null) typedListener.ExitFixed_array_type(this);
		}
	}

	[RuleVersion(0)]
	public Fixed_array_typeContext fixed_array_type() {
		Fixed_array_typeContext _localctx = new Fixed_array_typeContext(Context, State);
		EnterRule(_localctx, 14, RULE_fixed_array_type);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 45; type();
			State = 46; Match(OPEN_BRACKET);
			State = 47; Match(INTEGER_LITERAL);
			State = 48; Match(CLOSE_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x17', '\x35', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x5', '\x2', '\x19', '\n', '\x2', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x5', '\x3', '\x1E', '\n', 
		'\x3', '\x3', '\x4', '\x3', '\x4', '\x3', '\x5', '\x3', '\x5', '\x3', 
		'\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\a', '\x3', '\a', 
		'\x5', '\a', '*', '\n', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', 
		'\b', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', 
		'\x3', '\t', '\x2', '\x2', '\n', '\x2', '\x4', '\x6', '\b', '\n', '\f', 
		'\xE', '\x10', '\x2', '\x3', '\x3', '\x2', '\x3', '\x12', '\x2', '\x30', 
		'\x2', '\x18', '\x3', '\x2', '\x2', '\x2', '\x4', '\x1D', '\x3', '\x2', 
		'\x2', '\x2', '\x6', '\x1F', '\x3', '\x2', '\x2', '\x2', '\b', '!', '\x3', 
		'\x2', '\x2', '\x2', '\n', '#', '\x3', '\x2', '\x2', '\x2', '\f', ')', 
		'\x3', '\x2', '\x2', '\x2', '\xE', '+', '\x3', '\x2', '\x2', '\x2', '\x10', 
		'/', '\x3', '\x2', '\x2', '\x2', '\x12', '\x13', '\x5', '\x4', '\x3', 
		'\x2', '\x13', '\x14', '\a', '\x2', '\x2', '\x3', '\x14', '\x19', '\x3', 
		'\x2', '\x2', '\x2', '\x15', '\x16', '\x5', '\f', '\a', '\x2', '\x16', 
		'\x17', '\a', '\x2', '\x2', '\x3', '\x17', '\x19', '\x3', '\x2', '\x2', 
		'\x2', '\x18', '\x12', '\x3', '\x2', '\x2', '\x2', '\x18', '\x15', '\x3', 
		'\x2', '\x2', '\x2', '\x19', '\x3', '\x3', '\x2', '\x2', '\x2', '\x1A', 
		'\x1E', '\x5', '\x6', '\x4', '\x2', '\x1B', '\x1E', '\x5', '\b', '\x5', 
		'\x2', '\x1C', '\x1E', '\x5', '\n', '\x6', '\x2', '\x1D', '\x1A', '\x3', 
		'\x2', '\x2', '\x2', '\x1D', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x1D', 
		'\x1C', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x5', '\x3', '\x2', '\x2', 
		'\x2', '\x1F', ' ', '\t', '\x2', '\x2', '\x2', ' ', '\a', '\x3', '\x2', 
		'\x2', '\x2', '!', '\"', '\a', '\x17', '\x2', '\x2', '\"', '\t', '\x3', 
		'\x2', '\x2', '\x2', '#', '$', '\a', '\x17', '\x2', '\x2', '$', '%', '\a', 
		'\x13', '\x2', '\x2', '%', '&', '\a', '\x17', '\x2', '\x2', '&', '\v', 
		'\x3', '\x2', '\x2', '\x2', '\'', '*', '\x5', '\xE', '\b', '\x2', '(', 
		'*', '\x5', '\x10', '\t', '\x2', ')', '\'', '\x3', '\x2', '\x2', '\x2', 
		')', '(', '\x3', '\x2', '\x2', '\x2', '*', '\r', '\x3', '\x2', '\x2', 
		'\x2', '+', ',', '\x5', '\x4', '\x3', '\x2', ',', '-', '\a', '\x14', '\x2', 
		'\x2', '-', '.', '\a', '\x15', '\x2', '\x2', '.', '\xF', '\x3', '\x2', 
		'\x2', '\x2', '/', '\x30', '\x5', '\x4', '\x3', '\x2', '\x30', '\x31', 
		'\a', '\x14', '\x2', '\x2', '\x31', '\x32', '\a', '\x16', '\x2', '\x2', 
		'\x32', '\x33', '\a', '\x15', '\x2', '\x2', '\x33', '\x11', '\x3', '\x2', 
		'\x2', '\x2', '\x5', '\x18', '\x1D', ')',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace RobSharper.Ros.MessageEssentials.RosTypeParser
